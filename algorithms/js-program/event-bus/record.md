为什么要实现自定义事件总线，而不用ahooks的useEventEmitter？
* ahooks的useEventEmitter设计是用于组件间通信，它没有提供全局的事件总线，而是每个useEventEmitter调用都会创建一个新的事件发射器实例。这意味着它不适合在全局范围内共享事件（比如整个应用级别的通信），而更适合于局部组件间（例如父子、兄弟）的通信。

具体区别：
作用域不同：自实现的EventEmitter通过Context可以在整个组件树中共享同一个实例，因此可以实现跨任意层级的组件通信（全局事件总线）。ahooks的useEventEmitter创建的事件发射器是局部的，通常需要在组件间通过props传递，或者结合Context来实现跨组件通信。

生命周期管理： 自实现的`useListener`在组件内部使用，会自动在组件卸载时取消订阅，避免内存泄漏。

自实现的优势：
1. 全局事件总线：整个应用共享一个事件中心，任何组件都可以通过Context获取到同一个EventEmitter实例，方便跨任意组件通信。
2. 自动取消订阅：通过`useListener`钩子，在组件卸载时自动移除监听，简化了开发者的工作，避免内存泄漏。
3. 与React深度集成：通过自定义Hook和Context，提供了符合React开发习惯的API。
自实现的事件总线方案适合需要全局事件通信的场景，并且通过自动取消订阅简化了开发。而ahooks的useEventEmitter更适合局部组件通信（比如同一个父组件下的兄弟组件）。

因此，在当前的权限管理实现方案中，由于需要全局通信（用户切换项目时，多个组件需要更新状态），使用自实现的全局事件总线是合理的。如果使用ahooks的useEventEmitter，我们还需要自己实现全局实例的管理和自动取消订阅，反而增加了复杂度。

面试官：“为什么不直接用 ahooks？”
高阶回答：
“ahooks 在组件级通信场景很优秀，但面对 跨应用状态同步+业务规则嵌入 的需求时存在架构断层：

无法扩展业务协议：如权限校验需侵入每个事件监听函数；

无生命周期控制：项目切换时需手动清理遗留监听器；

缺失企业级特性：如事件持久化对金融级应用至关重要。
我们通过自研方案将 业务规则下沉到基础设施层，使业务代码更纯粹。”



与发布订阅模式的关系：
自研的EventEmitter就是一个典型的发布订阅模式的实现。发布订阅模式定义了一种一对多的依赖关系，
当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知。EventEmitter中的emit就是发布，add/remove就是订阅和取消订阅。

事件总线 vs Redux：
- 事件总线（发布订阅）适用于组件间的事件通信，特别是非父子组件间的通信。它更轻量，适用于事件驱动的场景。
- Redux是一个全局状态管理库，它维护一个全局的状态树，通过reducer来纯函数式地更新状态，然后通知订阅者（组件）状态变化。

优势：
- 事件总线：
* 轻量级，实现简单。
* 适合一次性事件（比如保存操作完成的通知）或非状态类的通信（比如触发一个动作）。
* 不需要将状态集中存储，而是通过事件传递数据。

Redux：
* 提供可预测的状态管理，通过纯函数更新状态，便于追踪状态变化。
* 提供中间件机制（如异步处理、日志等）。
* 适合管理全局的、复杂的状态（如用户登录状态、主题等）。


是否需要使用Redux实现？
- 如果业务场景主要是事件通知（比如切换项目、保存数据等动作），而不涉及复杂的状态管理，那么事件总线更合适。
- 如果涉及大量的状态需要共享，并且状态之间有复杂的更新逻辑，那么Redux（或类似的状态管理库）更合适

总结：
自研事件总线与ahooks的useEventEmitter在功能上有重叠，但自研实现更强调通过Context共享事件实例，而ahooks需要手动管理实例共享。
- 自研事件总线是发布订阅模式的一种实现。
- 相比Redux，事件总线更适合事件通信，而Redux适合集中状态管理。根据具体场景选择，如果只是组件通信，事件总线更轻量合理。
因此，当前方案在满足需求（项目切换事件通信）上是合理的，且自研实现提供了更好的控制性和与现有项目的集成度。




----------------云发行项目梳理----------
1、项目一键切换各页面同步展示
* 首先需要根据用户权限判断当前用户：发行超级管理员、发行BD、发行项目负责人、影院超级管理员
* 用户是发行超级管理员，是可以创建影片项目的，可以添加多个影片进行审核。如果存在多个项目，需要可执行项目切换，切换后对应的页面都统一根据项目变更。只有添加了项目后，才可进度自促活动发布、营销活动发布等操作。
  如果角色正确的情况下，
  如果存在项目的话，会先默认展示当前项目信息（从接口获取）最终信息，当前项目信息获取中存在的逻辑是：
    先判断localStorage 中是否存在cloudCurrentProjectData 项目信息数据：
      * 如果存在，且项目ID一致，则更新当前项目信息，直接发送事件控制，不需要更新storage中的数据，如果缓存中没找到，还需要更新storage中的数据并通过event.emit 发送一个事件通知，即最新的项目信息。
      * 不存在，则需要先更新storage中的数据，更新当前项目信息，并通过event.emit 发送一个事件通知，即最新的项目信息。
    如果接口返回无项目，则更新项目信息为空，且需要移除掉storage中的缓存项目数据，
  只有有项目的情况下，才能进行项目切换。否则只能先添加项目。
  如果切换项目成功后，更新当前项目信息，发送事件通知。
  * 发行BD是需要发行方超级管理员分配影片项目。
* 左侧侧边栏也是根据用户角色定义判断展示。


基于业务场景项目切换，涉及所有与项目相关页面需要实时更新需求，实现自定义事件总线EventEmitter，并通过Context在整个组件树中共享同一个实例，来实现跨任意层级的组件通信，

2、复杂的页面交互
基于 React 使用了 useReducer 和 Context 来管理和共享状态， 实现轻量级的状态管理方案。它主要用于管理筛选条件（filters）以及页面刷新和数据刷新相关的状态。
基于复杂的页面交互实现了一个简单的状态管理系统，主要用于管理筛选条件和刷新标志。通过 useReducer 和 Context 的结合，状态可以在组件树中共享，并且状态更新逻辑集中在 reducer 中，便于维护和扩展。

设计轻量级的状态管理方案，使用useReducer + Context 来管理和共享状态，解决数据报表（9+状态下的多字段展示/7+筛选维度）的复杂交互；  
